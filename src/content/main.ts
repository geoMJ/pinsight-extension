/*
 * Pinterest AI Blocker : removes AI-generated content from your Pinterest feed and search results
 * By Marianne J
 * Thanks for checking out my project!
 */

/**********  QUEUE MECHANISM **********/

/* Holds pins that need to be checked (their url, and wrapper element) */
const pinQueue: [string, HTMLDivElement][] = [];
let isProcessing = false;

/** Utility function used to avoid too many requests to the server when checking pins */
const processPinQueue = async () => {
    if (isProcessing) return;
    isProcessing = true;

    while (pinQueue.length > 0) {
        const [url, wrapper] = pinQueue.shift() as [string, HTMLDivElement];
        await processPinLink(url, wrapper);

        await new Promise((resolve) => setTimeout(resolve, 200));
    }

    isProcessing = false;
};

/** Adds a pin to the queue and calls the processing function if nothing else is being checked at the moment */
const enqueuePinCheck = (pinUrl: string, pinWrapper: HTMLDivElement) => {
    pinQueue.push([pinUrl, pinWrapper]);
    if (!isProcessing) processPinQueue();
};

/** Map to store and classify processed pins so we don't re-check them (and re-send requests) */
const processedPins = new Map<string, "human" | "ai">();

/** Parses the nodes that are inside the Pinterest grid and processes them */
const parseNodes = (nodes: NodeList) => {
    const validBodes = Array.from(nodes).filter(
        (node) =>
            node instanceof HTMLDivElement &&
            node.matches("[data-grid-item='true']")
    ) as HTMLDivElement[];
    for (const node of validBodes) {
        const pinWrapper =
            (node.querySelector(
                "[data-test-id='pinWrapper']"
            ) as HTMLDivElement) || null;
        if (pinWrapper) updatePinGrid(pinWrapper);
    }
};

/**********  PIN REMOVAL LOGIC **********/

/** Hides the pin (the other grid elements will adjust accordingly) */
const removePin = (pinWrapper: HTMLDivElement) => {
    pinWrapper.style.display = "none";
    const footer = pinWrapper.nextElementSibling as HTMLDivElement | null;
    if (footer) {
        footer.style.height = "1px";
        footer.style.overflow = "hidden";
    }
};

/** Checks if a pin is tagged as AI-generated by Pinterest */
const processPinLink = async (pinUrl: string, pinWrapper: HTMLDivElement) => {
    const parser = new DOMParser();
    const pinPageResponse = await fetch(pinUrl);
    const htmlPageContent = await pinPageResponse.text();
    const doc = parser.parseFromString(htmlPageContent, "text/html");

    const contentIsAI =
        doc.querySelector("[data-test-id*='ai-generated']") !== null;
    processedPins.set(pinUrl, contentIsAI ? "ai" : "human");

    if (contentIsAI) return removePin(pinWrapper);
};

/** Main logic to process pins (or not if already processed) */
const updatePinGrid = (pinWrapper: HTMLDivElement) => {
    const pinLink = pinWrapper.querySelector("a");
    if (
        pinWrapper.querySelector("video") ||
        !pinLink ||
        !pinLink.href.includes("/pin/")
    )
        return;

    const url = pinLink.href;

    if (!processedPins.has(url)) return enqueuePinCheck(url, pinWrapper);
    else if (processedPins.get(url) === "ai") return removePin(pinWrapper);
};

/**********  MUTATION OBSERVER ***********/

/** Observes the Pinterest grid for new pins being added */
const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
        parseNodes(mutation.addedNodes);
    }
});

/********** BEGINNING ***********/

const reactRoot = document.getElementById("__PWS_ROOT__");
if (reactRoot) {
    observer.observe(reactRoot, { childList: true, subtree: true });
    // We need to do one round of manual check for the first few pins that won't get caught in the observer's mutations
    const pinList = document.querySelectorAll("[data-grid-item='true']");
    if (pinList) parseNodes(pinList);
}
