/*
 * Pinterest AI Blocker : removes AI-generated content from your Pinterest feed and search results
 * By Marianne J
 * Thanks for checking out my project!
 */

import { PinDisplayMode } from "@/utils/types";
import { getOptions } from "./options";

const state = {
    currentPinDisplayMode: "hidden" as PinDisplayMode,
};

/**********  QUEUE MECHANISM **********/

/* Holds pins that need to be checked (their url, and wrapper element) */
const MAX_CONCURRENT_CHECKS = 3;
const pinQueue: [string, HTMLDivElement][] = [];
let currentChecks = 0;
//let isProcessing = false;

// TODO Maybe set this as an option ?

/** Utility function used to avoid too many requests to the server when checking pins */
// const processPinQueue = async () => {
//     if (isProcessing) return;
//     isProcessing = true;

//     while (pinQueue.length > 0) {
//         const [url, wrapper] = pinQueue.shift() as [string, HTMLDivElement];
//         await processPinLink(url, wrapper);

//         await new Promise((resolve) => setTimeout(resolve, 100));
//     }

//     isProcessing = false;
// };

const processPinQueueConcurrently = async () => {
    while (pinQueue.length > 0 && currentChecks < MAX_CONCURRENT_CHECKS) {
        currentChecks++;
        const [url, wrapper] = pinQueue.shift() as [string, HTMLDivElement];
        processPinLink(url, wrapper).finally(() => {
            currentChecks--;
            processPinQueueConcurrently();
        });
        await new Promise((resolve) => setTimeout(resolve, 100));
    }
};

const processingFunction = processPinQueueConcurrently;

/** Adds a pin to the queue and calls the processing function if nothing else is being checked at the moment */
const enqueuePinCheck = (pinUrl: string, pinWrapper: HTMLDivElement) => {
    pinQueue.push([pinUrl, pinWrapper]);
    processingFunction();
};

/** Map to store and classify processed pins so we don't re-check them (and re-send requests) */
const processedPins = new Map<string, "human" | "ai">();

/** Parses the nodes that are inside the Pinterest grid and processes them */
const parseNodes = (nodes: NodeList) => {
    const validBodes = Array.from(nodes).filter(
        (node) =>
            node instanceof HTMLDivElement &&
            node.matches("[data-grid-item='true']")
    ) as HTMLDivElement[];
    for (const node of validBodes) {
        const pinWrapper =
            (node.querySelector(
                "[data-test-id='pinWrapper']"
            ) as HTMLDivElement) || null;
        if (pinWrapper) updatePinGrid(pinWrapper);
    }
};

/**********  PIN REMOVAL LOGIC **********/

/** Hides the pin (the other grid elements will adjust accordingly) */
const changePinDisplayMode = (
    pinWrapper: HTMLDivElement,
    mode: PinDisplayMode
) => {
    const unblurButton = document.createElement("button");
    unblurButton.className = "unblur-button";
    unblurButton.textContent = "Show AI Content";
    unblurButton.addEventListener("click", () => {
        pinWrapper.setAttribute("data-ai-pin", "labelled");
        unblurButton.remove();
    });
    pinWrapper.appendChild(unblurButton);
    pinWrapper.setAttribute("data-ai-pin", mode);
};

const fetchPinPage = (url: string): Promise<string | null> => {
    return new Promise((resolve) => {
        chrome.runtime.sendMessage(
            { type: "CHECK_PIN_PAGE", url },
            (response) => {
                if (response && response.success) {
                    resolve(response.html);
                } else {
                    resolve(null);
                }
            }
        );
    });
};

/** Checks if a pin is tagged as AI-generated by Pinterest */
const processPinLink = async (pinUrl: string, pinWrapper: HTMLDivElement) => {
    const parser = new DOMParser();
    const pinPageHTML = await fetchPinPage(pinUrl);
    if (!pinPageHTML) {
        console.error(
            "Problem occured when checking if pin is AI-generated",
            pinUrl
        );
        return;
    }
    const doc = parser.parseFromString(pinPageHTML, "text/html");

    const contentIsAI =
        doc.querySelector("[data-test-id*='ai-generated']") !== null;
    processedPins.set(pinUrl, contentIsAI ? "ai" : "human");

    if (contentIsAI)
        return changePinDisplayMode(pinWrapper, state.currentPinDisplayMode);
};

/** Main logic to process pins (or not if already processed) */
const updatePinGrid = (pinWrapper: HTMLDivElement) => {
    const pinLink = pinWrapper.querySelector("a");
    if (
        pinWrapper.querySelector("video") ||
        !pinLink ||
        !pinLink.href.includes("/pin/")
    )
        return;

    const url = pinLink.href;

    if (!processedPins.has(url)) return enqueuePinCheck(url, pinWrapper);
    else if (processedPins.get(url) === "ai")
        return changePinDisplayMode(pinWrapper, state.currentPinDisplayMode);
};

/**********  MUTATION OBSERVER ***********/

/** Observes the Pinterest grid for new pins being added */
const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
        parseNodes(mutation.addedNodes);
    }
});

/********** BEGINNING ***********/

const initContentScript = async () => {
    // Getting options, display mode only for now
    const options = await getOptions();
    state.currentPinDisplayMode = options.blockingMode;

    const reactRoot = document.getElementById("__PWS_ROOT__");
    if (reactRoot) {
        observer.observe(reactRoot, { childList: true, subtree: true });
        // We need to do one round of manual check for the first few pins that won't get caught in the observer's mutations
        const pinList = document.querySelectorAll("[data-grid-item='true']");
        if (pinList) parseNodes(pinList);
    }
};

initContentScript();